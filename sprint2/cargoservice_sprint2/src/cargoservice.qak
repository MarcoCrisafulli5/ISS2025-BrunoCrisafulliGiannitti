System cargoservice
mqttBroker "localhost" : 1883 eventTopic "sonardata"  //CAMBIARE CON IP MACCHINA SU CUI GIRA BROKER QUANDO SARA SU RASP


Dispatch msg1 : msg1(X)
Event   cargoevent : cargoevent( INFO )

Event sonardata      : distance(D)   //emitted  by sonardevice or (better) by datacleaner

Request requesttoload : requesttoload (PID)
Reply replyrequesttoload : replyrequesttoload (X) for requesttoload

// Richieste interne da cargoservice a productpolice
Request productrequest : productrequest(PID) // from cargo1 to productservice (PID)
Reply productreply : productreply(PESO) for productrequest// from productservice to cargo1 with PID (PID, PESO)
Reply productreplyfailed : productreplyfailed (ARG) for productrequest



Request getProduct : product( ID )  
Reply   getProductAnswer: product( JSonString ) for getProduct 

Request sonarReq : sonarReq(X)
Reply sonarReply : sonarReply(X) for sonarReq
Reply sonarReplyFailure : sonarReplyFailure(X) for sonarReq

Request holdrequest : holdrequest(PESO, PID) //from cargo1 to cargohold, PESO ok?, SLOT liberi?, PID product
Reply holdreply : holdreply(SLOT, PID) for holdrequest // from cargohold to cargo1, SLOT assegnato, PID product
Reply holdreplyfailed : holdreplyfailed ( ARG ) for holdrequest


Request moverobot    :  moverobot(TARGETX, TARGETY)  
Reply moverobotdone  :  moverobotok(ARG)                    for moverobot
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobot

Request moverobotinternal    :  moverobot( SLOT )  
Reply moverobotdone  :  moverobotok(ARG)                    for moverobotinternal
Reply moverobotfailed:  moverobotfailed(PLANDONE, PLANTODO) for moverobotinternal


Request engage        : engage(OWNER, STEPTIME)	
Reply   engagedone    : engagedone(ARG)    for engage
Reply   engagerefused : engagerefused(ARG) for engage

Dispatch disengage    : disengage(ARG)

Context ctxcargoholdservice ip [host="localhost" port=8888]

//Context ctxsonarservice ip [host="127.0.0.1" port=8889] //context sonar fittizio per test 
//Context ctxsonarled2025 ip [ host= "localhost" port= 8128 ] // context per sonarLed2025
Context ctxbasicrobot ip [host="discoverable" port=8020]
Context ctxcargoservice ip [ host="discoverable" port=8111]
Context ctxusermock ip [ host="discoverable" port=8887]

ExternalQActor productservice context ctxcargoservice
ExternalQActor basicrobot context ctxbasicrobot
//ExternalQActor sonardevice context ctxsonarled2025
ExternalQActor user context ctxusermock



/*
 * Attore principale che si occupa di orchestrare il flusso di vita di una richiesta, dal momento della ricezione,
 * al momento della esecuzione.
 * Logica: Request -> Verifica PID -> Verifica Slot nella Hold e Peso -> Verifica Sonar -> CargoRobot muove il carico
 * 
 * Unico stato di richiesta rifiutata come fallback per ogni esito negativo della richiesta
 */
QActor cargoservice context ctxcargoholdservice{
	[#
			var ID = 0
			var PESO = 0
			var SLOT = 0
		//REGISTER	 
 		fun register(){
		
		if( CommUtils.ckeckEureka( ) ){
			val discoveryclient = CommUtils.registerService( main.java.EurekaServiceConfig() )
			CommUtils.outmagenta("discoveryclient=$discoveryclient ")
			CommUtils.outmagenta("EUREKA")
			
		}else{CommUtils.outmagenta("NON VA EUREKA")}
		
		
	}

		#]	
	State s0 initial {
		[# sysUtil.logMsgs=true #]
		[# register() #]

		println("myself=${myself.name}")
		println("curState=${currentState.stateName}")
		println("currentMsg=${currentMsg}")
		delay 500
	}Goto waitRequest
	
	State waitRequest{
		delay 500
		println("Awaiting Requests")
	}Transition t00 whenRequest requesttoload -> verifyProductID
	
	State verifyProductID{
		
		println("Request received - Verifying Product ID...")
		println("------------------------------------------")
		onMsg(requesttoload : requesttoload(PID)){
			[#
				var PID = payloadArg(0).toInt()
				println( PID )
				ID = PID
				CommUtils.outgreen(" PID=$PID ")
				#
			]
		}
	    create productpolice _"p1" //crea attore che si interfaccia con productservice
	    requestbycreator productrequest : productrequest($ID)
	    delay 500
		//replyTo requesttoload with replyrequesttoload : replyrequesttoload(X)
	} Transition t12 whenReply productreply ->	waitResponsePolice	
					whenReply productreplyfailed -> requestrefused
	State waitResponsePolice{
		onMsg(productreply : productreply(PESO)){
			[#
				PESO = payloadArg(0).toInt()
				CommUtils.outgreen(" PESO=$PESO ")
				#
			]
		}
	}	Goto verifyCargoHold if [# PESO!=0 #] else 	requestrefused
	
//	Richiesta con ID prodotto valido, si procede al controllo sulla hold		
	State verifyCargoHold{
		println("Product Id found in Database - Verifying Cargo Hold Slots Availability and Weight...")
		println("------------------------------------------")
		request hold -m holdrequest : holdrequest($PESO, $ID)
		delay 5000
		//logica per mandare request alla hold
	} Transition t11 whenReply holdreply -> handleHoldReply
					whenReply holdreplyfailed -> requestrefused
	
	// Riceve lo slot assegnato
	State handleHoldReply {
		onMsg(holdreply : holdreply(SLOT, PID)) {
			[#
				SLOT = payloadArg(0).toInt()
				CommUtils.outblue("CargoService | Slot assegnato=$SLOT")
			#]
		}
	} Goto verifySonar if [# SLOT != 0 #] else requestrefused
	
	
//	State verifySonar{
//		printCurrentMessage
//		//request cargorobot -m moverobot : moverobot(1)
//		delay 5000
//		request productservice -m getProduct : getProduct(1)
//	}
	
//	
	
	// Aspetta il segnale del sonar per conoscere la posizione IOPORT
	State verifySonar {
		println("CargoService | Waiting for sonardata to know IOPORT position...")
		request sonaradapter -m sonarReq : sonarReq(X)
	} Transition t0 whenReply sonarReply -> move
					whenReply sonarReplyFailure -> sonarErrorRetry
	
	State sonarErrorRetry{
		delay 200
		println("CargoService | SONAR failure -- retrying ")
		request sonaradapter -m sonarReq : sonarReq(X)
		
	}Transition t1 whenReply sonarReply -> move
					whenReply sonarReplyFailure -> sonarErrorRetry
	
	
	// Chiama il robot passando lo slot
	State move {
		println("CargoService | Engaging robot for delivery...")
		
		request cargorobot -m moverobotinternal : moverobot( $SLOT )
	} Transition t1 whenReply moverobotdone -> deliveryComplete
					  whenReply moverobotfailed -> requestrefused

	// Stato di completamento
	State deliveryComplete {
		println("CargoService | Delivery completed successfully!")
	} Goto waitRequest
	
/*
	State work{
		delay 500
		printCurrentMessage
		[# var PESO = 1000;
			var PID = 1;
			#]
		delay 1000
		request hold -m holdrequest : holdrequest(PESO, PID)
		delay 2000
	} Transition t1 whenReply holdreply -> handleReply
					whenReply holdreplyfailed -> handleReply
					
	State handleReply{
		onMsg(holdreply : holdreply (SLOT, PID)){
		[# var RequestArg = payloadArg(0) #]
      	println(" cargo1 receives the reply holdreply($RequestArg)")
      	}
      	onMsg(holdreplyfailed : holdreplyfailed (ARG)){
      	[# var RequestArg = payloadArg(0) #]
      	println(" cargo1 receives the replyfailed holdreplyfailed($RequestArg)")
      	}
	}Goto work
*/
	State requestrefused{
		println("ATTENTION - Request refused")
		println("---------------------------")
		delay 500
		//stato di ripiego se per qualsiasi motivo la richiesta fallisce
	} Goto waitRequest
}




/* Attore singleton che si occupa di interrogare productservice e ricevere un PID valido ed un peso
 * e passare questi parametri all'attore principale
 * Riceve productrequest
 * Risponde con productreply o productreplyfailed
 * */
QActor productpolice context ctxcargoholdservice dynamicOnly {
	[#
	var PID = 0	
	var productok: Boolean = true
	var WEIGHT = 0
	
	fun sendProductRequest(){
		
	}
	
	
	
	#]
	State s0 initial{
		println("-----------------PRODUCT POLICE--------------------")
		
	} Transition t00 whenRequest productrequest -> waitsendQuery
	
	State waitsendQuery{
		onMsg(productrequest : productrequest(ID)){
			[# PID = payloadArg(0).toInt()
				CommUtils.outblue("-------- Product PID ---------")
				println( PID ) 
				#]
			request productservice -m getProduct : product($PID) 
		} 
	}Transition t1 whenReply getProductAnswer -> receiveparseanswer
	
	State receiveparseanswer{
		onMsg(getProductAnswer : product( JSonString )){
			[# 	
				fun getDataFromAnswer(){
					var ANSWR = payloadArg(0)
					println(ANSWR)
					var parser = JSONParser()
					var jsonObject = parser.parse(ANSWR) as JSONObject
					var productId = (jsonObject["productId"] as Long).toInt()
					WEIGHT = (jsonObject["weight"] as Long).toInt()
					if (productId != PID) productok = false 
					}
			getDataFromAnswer()				#]				
		}
	} Goto productaccepted if [# productok #] else productunknown
	
	State productaccepted{
		replyTo productrequest with productreply: productreply($WEIGHT) 
	} Goto end
	
	State productunknown{
		replyTo productrequest with productreplyfailed : productreplyfailed(2)
	} Goto end
	
	State end {
		terminate 0
	}
} //actor productpolice


QActor cargorobot context ctxcargoholdservice {
	
	[# 
        var TARGETX = 0
        var TARGETY = 0
        var SLOT = 0
    #]

    State s0 initial {
        println("CargoRobot ready and waiting for movement requests...")
        delay 2000
    } 
    Goto waitRequest

    // Stato che aspetta richieste di movimento
    State waitRequest {
        println("CargoRobot | Waiting for load request...")
    } 
    Transition t0 whenRequest moverobotinternal -> engage

    // Stato di ingaggio del robot
    State engage {
        onMsg(moverobotinternal : moverobot( SLOT )) {
            [#
            	CommUtils.outblue("-------- Received request with SLOT ---------")
                var slot = payloadArg(0).toInt()
                println( slot ) 
                var coords = when(slot) {
                    1 -> Pair(1, 1)
                    2 -> Pair(4, 1)
                    3 -> Pair(1, 3)
                    4 -> Pair(4, 3)
                    else -> Pair(0, 0)
                }
                TARGETX = coords.first
                TARGETY = coords.second
                CommUtils.outblue("CargoRobot | Slot=$slot -> coords=($TARGETX,$TARGETY)")
            #]
            request basicrobot -m engage : engage($MyName, 330)
        }
    } 
    Transition t1 whenReply engagedone -> goToIOPort
                  whenReply engagerefused -> refused

    // Movimento verso IOPORT
    State goToIOPort {
    	delay 500
        println("CargoRobot | Moving to IOPORT to pick up cargo...")
        request basicrobot -m moverobot : moverobot(0, 4)
    } 
    Transition t2 whenReply moverobotdone -> goToTarget
                  whenReply moverobotfailed -> refused

    // Movimento verso target
    State goToTarget {
    	delay 2000
    	[#
        	CommUtils.outblue("CargoRobot | Delivering cargo to ($TARGETX,$TARGETY)")
    	#]
    	request basicrobot -m moverobot : moverobot($TARGETX, $TARGETY)
	}
 
    Transition t3 whenReply moverobotdone -> goHome
                  whenReply moverobotfailed -> refused

    // Ritorno alla base
    State goHome {
    	delay 1000
        println("CargoRobot | Returning to base...")
        request basicrobot -m moverobot : moverobot(0, 0)
    } 
    Transition t4 whenReply moverobotdone -> done
                  whenReply moverobotfailed -> refused

    // Stato finale
    State done {
        forward basicrobot -m disengage : disengage(ok)
        println("CargoRobot | Delivery completed.")
        replyTo moverobot with moverobotdone : moverobotok(ok)
    } 
    Goto s0

    // Stato di errore
    State refused {
        println("CargoRobot | Movement failed.")
        replyTo moverobot with moverobotfailed : moverobotfailed(no, no)
    } 
    Goto s0
}



QActor hold context ctxcargoholdservice {

  // ===== Kotlin "puro" a livello attore (NON dentro uno stato) =====
  [#
    // Stati slot
    var FREE = 0
    var RESERVED = 1
    var OCCUPIED = 2

    var MAXLOAD = 1000   // imposta dal requisito se diverso

    // 4 slot S1..S4: tre array paralleli
    var slotState = intArrayOf(FREE, FREE, FREE, FREE)
    var slotPid   = intArrayOf(0,    0,    0,    0)
    var slotPeso  = intArrayOf(0,    0,    0,    0)

    fun findFree(): Int {
      for (i in 0..3) if (slotState[i] == FREE) return i
      return -1
    }

    fun reserve(i: Int, pid: Int, peso: Int) {
      slotState[i] = RESERVED
      slotPid[i]   = pid
      slotPeso[i]  = peso
    }

    fun occupy(i: Int) {
      if (slotState[i] == RESERVED) slotState[i] = OCCUPIED
    }

    fun release(i: Int) {
      slotState[i] = FREE
      slotPid[i]   = 0
      slotPeso[i]  = 0
    }

    fun stateName(v:Int) = when(v){
      FREE->"FREE"; RESERVED->"RESERVED"; OCCUPIED->"OCCUPIED"; else->"?"
    }

    fun asString(): String =
      (0..3).joinToString(" ") { j ->
        "S${j+1}=${stateName(slotState[j])}(pid=${slotPid[j]},w=${slotPeso[j]})"
      }

    // Variabili per scambiare dati con le guardie QAK
    var lastPeso = -1
    var lastPid  = -1
    var lastIdx  = -1
    var invalid  = false
    var full     = false
    // (se vuoi aggiungere il controllo di sovrappeso)
    var overweight = false
  #]
  // ===== FSM =====
  State s0 initial {
    println("hold starting...") color green
    delay 300
  } Goto ready

 
  State ready {
    println("Hold ready: ${asString()}") color cyan
  }
  Transition t0 whenRequest holdrequest -> handleHoldReq

  State handleHoldReq {
	    printCurrentMessage color blue
	    onMsg( holdrequest : holdrequest(PESO, PID) ){
	      [#
	        // ---> quando passi ai payload reali, usa invece:
	         lastPeso = payloadArg(0).toInt()
	         lastPid  = payloadArg(1).toInt()
	
	        invalid    = (lastPeso <= 0 || lastPid <= 0)
	        overweight = (lastPeso > MAXLOAD)   
	        lastIdx    = findFree()
	        full       = (lastIdx < 0)
	      #]
	}
	autodispatch msg1 : msg1(1)
	} Transition t1
		whenMsg msg1 and [# invalid #] -> invalidPayload
		whenMsg msg1 and [# overweight #] -> overweight
		whenMsg msg1 and [# full #] -> full
		whenMsg msg1 and [# !invalid && !overweight && !full #] -> reserve
		
	
  State invalidPayload{
  		replyTo holdrequest with holdreplyfailed : holdreplyfailed(INVALID)
	      println("INVALID payload (PESO=${lastPeso}, PID=${lastPid})") color magenta
  } Goto ready
  
  State overweight{
  	replyTo holdrequest with holdreplyfailed : holdreplyfailed(OVERWEIGHT)
	println("OVERWEIGHT (PESO=${lastPeso} > MAXLOAD=${MAXLOAD})") color magenta
  }Goto ready
  
  State full{
  	 replyTo holdrequest with holdreplyfailed : holdreplyfailed(FULL)
	      println("FULL: ${asString()}") color magenta
  }Goto ready
  
  State reserve{
  	[#
	        reserve(lastIdx, lastPid, lastPeso)
	        var LASTPID = lastPid
	        var SLOTNUMBER = lastIdx + 1
	      #]
	      println("hold reserved S$SLOTNUMBER for PID=${lastPid} (w=${lastPeso}). State: ${asString()}") color magenta
	      replyTo holdrequest with holdreply : holdreply($SLOTNUMBER, $LASTPID)
  }Goto ready
}


	
	/* 
	 *-- approccio --
	 *  Assumo che il sonar invii dati 1 volta al secondo e verifico 1 volta alla prima ricezione dati e poi alla terza ricezione (approssima tempo 3 sec come da requisito) 
	 * 1. Attendi richiesta
	 * 2. Leggi distanza e verifica se regolare
	 *  3. Aspetta 2 secondi e ricontrolla distanza
	 *  4. Se distanza ok -> reply ---- se distanza not ok -> replyFailure
	 *  5. L'attore si esegue nuovamente su nuova richiesta in caso di fallimento
	 * 
	 */
QActor sonaradapter context ctxcargoholdservice {
	[#
			var D = 0 
			var DFREE = 10
			var GUASTO = false 
			#
		]
	State s0 initial {
		delay 200
		println("--------- sonaradapter ACTOR ONLINE -----------") color magenta
	} Goto awaitingRequest
	
	State awaitingRequest{
		println("--------- Waiting a Request -----------") color magenta
		onMsg( sonardata : distance(X) ){
			println("--------- Printing Sonar Data -----------") color magenta
			[#  D = payloadArg(0).toInt() #]
 			println("$name | handleSonardata D=$D DFREE=$DFREE") color magenta
 			}
	}Transition t0 whenRequest sonarReq -> handleRequest
	
	State handleRequest{
		onMsg(sonarReq : sonarReq(X)){
			println("---------SONAR REQUEST RECEIVED -------") color magenta
		}
	} Transition t1 whenEvent sonardata -> handleSonarData
	
	State handleSonarData{
		onMsg( sonardata : distance(X) ){
			[#  D = payloadArg(0).toInt() #]
 			println("$name | handleSonardata D=$D DFREE=$DFREE") color magenta
			if [# D > DFREE  #] { 
				println("from SONAR | ledON | FAILURE") color magenta
				[# GUASTO = true #]
			}
			if [# D <= DFREE/2  #] { 
				println("from SONAR | ledOFF | PRODOTTO TROVATO") color magenta
				[# GUASTO = false #]
			}
		}
		delay 2000
	}Transition t2 whenEvent sonardata -> verifyData
	
	State verifyData{
		onMsg( sonardata : distance(X) ){
			[#  D = payloadArg(0).toInt() #]
 			println("$name | handleSonardata D=$D DFREE=$DFREE") color cyan
			if [# D > DFREE  #] { 
				println("from SONAR | ledON | FAILURE") color magenta
				[# GUASTO = true #]
			}
			if [# D <= DFREE/2  #] { 
				println("from SONAR | ledOFF | PRODOTTO TROVATO") color magenta
				[# GUASTO = false #]
			}
		}
	}Goto productAtIOPort if [# !GUASTO #] else handleFailure 
	
	
	State productAtIOPort {
		replyTo sonarReq with sonarReply : sonarReply(ok)	
	} Goto awaitingRequest
	
	State handleFailure{
 		replyTo sonarReq with sonarReplyFailure : sonarReplyFailure(ok)		
	} Goto awaitingRequest
} 

/*
QActor hold context ctxcargoholdservice{
	State s0 initial{
		delay 1000
		[#
			val Slot1 = 0
			val Slot2 = 0
			val Slot3 = 0
			val Slot4 = 0
		#]
	}
	Transition t0 whenRequest isonline -> s1
		
	State s1{
		printCurrentMessage
		onMsg(isonline : isonline(X)){
			replyTo isonline with onlinereply : onlinereply(HOLD, ONLINE)
		}
	}Goto work
	
	State work{
		delay 5000
		println("working")
		forward cargoservice -m msg1 : msg1(1)
	} Transition t1 whenRequest holdrequest -> handleRequest
		
		
	State handleRequest{
		onMsg( holdrequest : holdrequest(PESO, PID)){
			[# val RequestArg = payloadArg(0) 
				#]
      		println(" cargohold receives the request holdrequest($RequestArg)")
			replyTo holdrequest with holdreply : holdreply(1, 1)
		}
	}
	Goto work
	
}
*/

